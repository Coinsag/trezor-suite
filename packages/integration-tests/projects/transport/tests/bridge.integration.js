const fetch = require('node-fetch').default;

// testing build. yarn workspace @trezor/transport build:lib is a required step therefore
const TrezorLink = require('../../../../transport/lib').default;

// messages are generated by docker/docker-transport-test.sh
const messages = require('../messages.json');

const { wait, setup, Controller } = global.Trezor;

const { BridgeV2 } = TrezorLink;

const controller = new Controller({
    url: 'ws://localhost:9001/',
});

jest.setTimeout(30000);

describe('bridge', () => {
    beforeEach(async () => {
        await setup(controller);

        await wait(1000);
    });

    // afterEach(() => {
    //     controller.disconnect();
    // });

    test('enumerate - acquire - getFeatures', async () => {
        BridgeV2.setFetch(fetch, true);

        const bridge = new BridgeV2();
        await bridge.init();
        await bridge.configure(messages);

        const enumerate = await bridge.enumerate();

        if (!enumerate.success) {
            return expect(enumerate.success).toEqual(true);
        }
        expect(enumerate.success).toEqual(true);

        console.log('devices', enumerate.payload);

        expect(enumerate.payload).toEqual([
            {
                path: '1',
                session: null,
                debugSession: null,
                product: 0,
                vendor: 0,
                debug: true,
            },
        ]);

        const acquire = await bridge.acquire({ path: enumerate.payload[0].path });

        if (!acquire.success) {
            return expect(acquire.success).toEqual(true);
        }

        const call = await bridge.call(acquire.payload.session, 'GetFeatures', {});

        if (!call.success) {
            return expect(call.success).toEqual(true);
        }

        expect(call.payload).toMatchObject({
            type: 'Features',
            message: {
                vendor: 'trezor.io',
                label: 'TrezorT',
            },
        });
    });

    // test('sessions stealing', async () => {
    //     BridgeV2.setFetch(fetch, true);

    //     const client1 = new BridgeV2();
    //     const client2 = new BridgeV2();

    //     await client1.init();

    //     client1.configure(messages);
    //     client2.configure(messages);

    //     const enumerate = await client1.enumerate();
    //     console.log('==== enumerate', enumerate);
    //     if (!enumerate.success) {
    //         return expect(enumerate.success).toEqual(true);
    //     }

    //     const session1 = await client1.acquire({ path: enumerate.payload[0].path, previous: enumerate.payload[0].session });
    //     console.log('session1', session1);

    //     if (!session1.success) {
    //         return expect(session1.success).toEqual(true);
    //     }

    //     let message = await client1.call(session1.payload.session, 'GetFeatures', {});
    //     console.log('message', message);
    //     if (!message.success) {
    //         return expect(message.success).toEqual(true);
    //     }

    //     expect(message.payload).toMatchObject({
    //         type: 'Features',
    //         message: {
    //             vendor: 'trezor.io',
    //             label: 'TrezorT',
    //         },
    //     });

    //     const session2 = await client2.acquire({ path: enumerate.payload[0].path, previous: enumerate.payload[0].session });
    //     console.log('session2', session2);

    //     if (!session2.success) {
    //         console.log('session2', session2);
    //         return expect(session2.success).toEqual(true);
    //     }

    //     message = await client2.call(session2.payload.session, 'GetFeatures', {});

    //     console.log('message', message);
    //     // const session1 = await client1.acquire({ path: devices[0].path });
    // });
});
